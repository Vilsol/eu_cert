// Autogenerated from Pigeon (v1.0.12), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

class NameData {
  String? Forename;
  String? Surname;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['Forename'] = Forename;
    pigeonMap['Surname'] = Surname;
    return pigeonMap;
  }

  static NameData decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return NameData()
      ..Forename = pigeonMap['Forename'] as String?
      ..Surname = pigeonMap['Surname'] as String?;
  }
}

class VaccinationEntry {
  String? TargetAgent;
  String? VaccineOrProphylaxis;
  String? VaccineMedicalProduct;
  String? MarketingAuthorizationHolder;
  int? DoseNumber;
  int? TotalDoses;
  String? DateOfVaccination;
  String? CountryOfVaccination;
  String? CertificateIssuer;
  String? UVCI;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['TargetAgent'] = TargetAgent;
    pigeonMap['VaccineOrProphylaxis'] = VaccineOrProphylaxis;
    pigeonMap['VaccineMedicalProduct'] = VaccineMedicalProduct;
    pigeonMap['MarketingAuthorizationHolder'] = MarketingAuthorizationHolder;
    pigeonMap['DoseNumber'] = DoseNumber;
    pigeonMap['TotalDoses'] = TotalDoses;
    pigeonMap['DateOfVaccination'] = DateOfVaccination;
    pigeonMap['CountryOfVaccination'] = CountryOfVaccination;
    pigeonMap['CertificateIssuer'] = CertificateIssuer;
    pigeonMap['UVCI'] = UVCI;
    return pigeonMap;
  }

  static VaccinationEntry decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return VaccinationEntry()
      ..TargetAgent = pigeonMap['TargetAgent'] as String?
      ..VaccineOrProphylaxis = pigeonMap['VaccineOrProphylaxis'] as String?
      ..VaccineMedicalProduct = pigeonMap['VaccineMedicalProduct'] as String?
      ..MarketingAuthorizationHolder = pigeonMap['MarketingAuthorizationHolder'] as String?
      ..DoseNumber = pigeonMap['DoseNumber'] as int?
      ..TotalDoses = pigeonMap['TotalDoses'] as int?
      ..DateOfVaccination = pigeonMap['DateOfVaccination'] as String?
      ..CountryOfVaccination = pigeonMap['CountryOfVaccination'] as String?
      ..CertificateIssuer = pigeonMap['CertificateIssuer'] as String?
      ..UVCI = pigeonMap['UVCI'] as String?;
  }
}

class TestEntry {
  String? TargetAgent;
  String? TestType;
  String? TestName;
  String? TestManufacturer;
  String? SampleCollected;
  String? TestResult;
  String? TestingCentre;
  String? CountryOfTest;
  String? CertificateIssuer;
  String? UVCI;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['TargetAgent'] = TargetAgent;
    pigeonMap['TestType'] = TestType;
    pigeonMap['TestName'] = TestName;
    pigeonMap['TestManufacturer'] = TestManufacturer;
    pigeonMap['SampleCollected'] = SampleCollected;
    pigeonMap['TestResult'] = TestResult;
    pigeonMap['TestingCentre'] = TestingCentre;
    pigeonMap['CountryOfTest'] = CountryOfTest;
    pigeonMap['CertificateIssuer'] = CertificateIssuer;
    pigeonMap['UVCI'] = UVCI;
    return pigeonMap;
  }

  static TestEntry decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TestEntry()
      ..TargetAgent = pigeonMap['TargetAgent'] as String?
      ..TestType = pigeonMap['TestType'] as String?
      ..TestName = pigeonMap['TestName'] as String?
      ..TestManufacturer = pigeonMap['TestManufacturer'] as String?
      ..SampleCollected = pigeonMap['SampleCollected'] as String?
      ..TestResult = pigeonMap['TestResult'] as String?
      ..TestingCentre = pigeonMap['TestingCentre'] as String?
      ..CountryOfTest = pigeonMap['CountryOfTest'] as String?
      ..CertificateIssuer = pigeonMap['CertificateIssuer'] as String?
      ..UVCI = pigeonMap['UVCI'] as String?;
  }
}

class RecoveryEntry {
  String? TargetAgent;
  String? FirstPositiveResult;
  String? DateValidFrom;
  String? DateValidUntil;
  String? CountryOfTest;
  String? CertificateIssuer;
  String? UVCI;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['TargetAgent'] = TargetAgent;
    pigeonMap['FirstPositiveResult'] = FirstPositiveResult;
    pigeonMap['DateValidFrom'] = DateValidFrom;
    pigeonMap['DateValidUntil'] = DateValidUntil;
    pigeonMap['CountryOfTest'] = CountryOfTest;
    pigeonMap['CertificateIssuer'] = CertificateIssuer;
    pigeonMap['UVCI'] = UVCI;
    return pigeonMap;
  }

  static RecoveryEntry decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return RecoveryEntry()
      ..TargetAgent = pigeonMap['TargetAgent'] as String?
      ..FirstPositiveResult = pigeonMap['FirstPositiveResult'] as String?
      ..DateValidFrom = pigeonMap['DateValidFrom'] as String?
      ..DateValidUntil = pigeonMap['DateValidUntil'] as String?
      ..CountryOfTest = pigeonMap['CountryOfTest'] as String?
      ..CertificateIssuer = pigeonMap['CertificateIssuer'] as String?
      ..UVCI = pigeonMap['UVCI'] as String?;
  }
}

class CertificatePayload {
  String? Version;
  NameData? Name;
  String? DateOfBirth;
  List<VaccinationEntry?>? Vaccinations;
  List<TestEntry?>? Tests;
  List<RecoveryEntry?>? Recoveries;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['Version'] = Version;
    pigeonMap['Name'] = Name == null ? null : Name!.encode();
    pigeonMap['DateOfBirth'] = DateOfBirth;
    pigeonMap['Vaccinations'] = Vaccinations;
    pigeonMap['Tests'] = Tests;
    pigeonMap['Recoveries'] = Recoveries;
    return pigeonMap;
  }

  static CertificatePayload decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return CertificatePayload()
      ..Version = pigeonMap['Version'] as String?
      ..Name = pigeonMap['Name'] != null
          ? NameData.decode(pigeonMap['Name']!)
          : null
      ..DateOfBirth = pigeonMap['DateOfBirth'] as String?
      ..Vaccinations = (pigeonMap['Vaccinations'] as List<Object?>?)?.cast<VaccinationEntry?>()
      ..Tests = (pigeonMap['Tests'] as List<Object?>?)?.cast<TestEntry?>()
      ..Recoveries = (pigeonMap['Recoveries'] as List<Object?>?)?.cast<RecoveryEntry?>();
  }
}

class _DecoderAPICodec extends StandardMessageCodec {
  const _DecoderAPICodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CertificatePayload) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is NameData) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is RecoveryEntry) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is TestEntry) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is VaccinationEntry) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return CertificatePayload.decode(readValue(buffer)!);
      
      case 129:       
        return NameData.decode(readValue(buffer)!);
      
      case 130:       
        return RecoveryEntry.decode(readValue(buffer)!);
      
      case 131:       
        return TestEntry.decode(readValue(buffer)!);
      
      case 132:       
        return VaccinationEntry.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class DecoderAPI {
  /// Constructor for [DecoderAPI].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  DecoderAPI({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _DecoderAPICodec();

  Future<CertificatePayload> decode(Uint8List arg_data) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DecoderAPI.decode', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_data]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as CertificatePayload?)!;
    }
  }
}
